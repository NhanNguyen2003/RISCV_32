/*
 * This source file was generated by the Gradle 'init' task
 */
package cse311;

import cse311.Enum.MemoryMode;
import cse311.kernel.Kernel;
import cse311.kernel.KernelConfig;
import cse311.programs.InitTask;
import java.io.File;

public class App {
    public static final String file_seperator = System.getProperty("file.separator");

    public static void main(String[] args) {
        System.out.println("==========================================");
        System.out.println("      RISC-V Java Kernel Bootloader       ");
        System.out.println("==========================================");

        try {
            // --------------------------------------------------------
            // 1. HARDWARE INIT
            // --------------------------------------------------------
            // Initialize 128MB RAM, CPU, Memory Management Techniques
            RV32Computer computer = new RV32Computer(128 * 1024 * 1024, 100, MemoryMode.CONTIGUOUS);
            Kernel kernel = computer.getKernel();

            // --------------------------------------------------------
            // 2. KERNEL CONFIGURATION
            // --------------------------------------------------------
            // Use Round Robin to allow Init, Shell, and User apps to share CPU
            kernel.getConfig().setSchedulerType(KernelConfig.SchedulerType.ROUND_ROBIN);
            // 5 instructions per slice
            kernel.getConfig().setTimeSlice(5);

            // --------------------------------------------------------
            // 3. LAUNCH INIT PROCESS (PID 1)
            // Java Simulated Init Task or from ELF
            // --------------------------------------------------------
            System.out.println("Bootloader: Spawning Init process (PID 1)...");
            // First Option: Simulated Init (Not tested yet)
            // We only need to create InitTask manually.
            // The InitTask code (InitTask.java) will automatically detect
            // that the Shell is missing and spawn ShellTask for us.
            // InitTask initTask = new InitTask(1, kernel);
            // kernel.addTaskToScheduler(initTask);

            // Second Option: Loading Init.elf
            // Pass a filename (e.g., "init.elf"), we load it now.
            // This is like adding a service to startup scripts.

            String elfPath = "User_Program_ELF" + file_seperator + "init.elf";
            System.out.println("Current working directory: " + System.getProperty("user.dir"));
            System.out.println("Looking for ELF at: " + elfPath);
            File f = new File(elfPath);
            System.out.println("File exists: " + f.exists());
            System.out.println("Absolute path: " + f.getAbsolutePath());
            if (f.exists()) {
                System.out.println("Bootloader: Pre-loading user ELF: " + elfPath);
                kernel.createTask(elfPath);
            }
            // }

            // --------------------------------------------------------
            // 4. START KERNEL
            // --------------------------------------------------------
            // This blocks forever in the mainLoop().
            // 1. Scheduler picks InitTask -> InitTask spawns ShellTask
            // 2. Scheduler picks ShellTask -> ShellTask prints "$" and waits for input
            System.out.println("Bootloader: Starting Kernel scheduler...");
            System.out.println("------------------------------------------");
            kernel.start();

        } catch (NullPointerException e) {
            System.err.println("Path invalid: " + e.getMessage());
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("\nKERNEL PANIC: " + e.getMessage());
            e.printStackTrace();
        } finally {
            System.out.println("\nSystem Halted.");
        }
    }
}